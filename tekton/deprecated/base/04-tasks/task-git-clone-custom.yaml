# Task: git-clone-custom
#
# Enhancements:
# Clones two repos, source code and deployment manifests
---
apiVersion: tekton.dev/v1beta1
kind: ClusterTask
metadata:
  name: git-clone-custom
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.12.1"
    tekton.dev/categories: "Developer Tools"
    tekton.dev/tags: "git"
    tekton.dev/displayName: "Git clone"
    tekton.dev/platforms: "linux/amd64"
spec:
  description: >-
     These Tasks are Git tasks to work with repositories used by other tasks in your Pipeline. The git-clone Task will clone a repo from the provided url into the output Workspace. By default the repo will be cloned into the root of your Workspace. You can clone into a subdirectory by setting this Task's subdirectory param. This Task also supports sparse checkouts. To perform a sparse checkout, pass a list of comma separated directory patterns to this Task's sparseCheckoutDirectories param.
  workspaces:
    - name: source
      description: A workspace that contains the file which needs to be altered.
  params:
    - description: git url of the source code to clone
      name: GIT_URL
      type: string
    - description: git url of the config repo to clone
      name: GIT_CONFIG_URL
      type: string
    - default: ''
      description: 'source code git revision to checkout (branch, tag, sha, ref…)'
      name: GIT_REVISION
      type: string
    - default: ''
      description: 'config repo git revision to checkout (branch, tag, sha, ref…)'
      name: GIT_CONFIG_REVISION
      type: string
    - default: ''
      description: (optional) git refspec to fetch before checking out revision
      name: GIT_REF
      type: string
    - default: ''
      description: (optional) git refspec to fetch before checking out revision
      name: GIT_CONFIG_REF
      type: string
    - default: 'true'
      description: defines if the resource should initialize and fetch the submodules
      name: GIT_SUBMODULES
      type: string
    - default: 'true'
      description: defines if the resource should initialize and fetch the submodules
      name: GIT_CONFIG_SUBMODULES
      type: string
    - default: '1'
      description: >-
        performs a shallow clone where only the most recent commit(s) will be
        fetched
      name: GIT_DEPTH
      type: string
    - default: '1'
      description: >-
        performs a shallow clone where only the most recent commit(s) will be
        fetched
      name: GIT_CONFIG_DEPTH
      type: string
    - default: 'true'
      description: >-
        defines if http.sslVerify should be set to true or false in the global
        git config
      name: GIT_SSL_VERIFY
      type: string
    - default: 'true'
      description: >-
        defines if http.sslVerify should be set to true or false in the global
        git config
      name: GIT_CONFIG_SSL_VERIFY
      type: string
    - default: ''
      description: >-
        defines which directories patterns to match or exclude when performing a
        sparse checkout
      name: GIT_SPARSE_CHECKOUT_DIRS
      type: string
    - default: ''
      description: >-
        defines which directories patterns to match or exclude when performing a
        sparse checkout
      name: GIT_CONFIG_SPARSE_CHECKOUT_DIRS
      type: string
    - default: 'true'
      description: >-
        clean out the contents of the repo's destination directory (if it
        already exists) before trying to clone the repo there
      name: GIT_DELETE_EXISTING
      type: string
    - default: ''
      description: git HTTP proxy server for non-SSL requests
      name: HTTP_PROXY
      type: string
    - default: ''
      description: git HTTPS proxy server for SSL requests
      name: HTTPS_PROXY
      type: string
    - default: ''
      description: git no proxy - opt out of proxying HTTP/HTTPS requests
      name: NO_PROXY
      type: string
    - default: 'true'
      description: log the commands used during execution
      name: VERBOSE
      type: string
    - name: CONTEXT_DIR_SOURCE
      type: string
      description: Context directory
      default: 'src'
    - name: CONTEXT_DIR_CONFIG
      type: string
      description: Context directory
      default: 'src_manifest'
    - name: GIT_IMAGE
      type: string
      description: The git image to use.
      default: registry.redhat.io/openshift-pipelines/pipelines-git-init-rhel8@sha256:afc5d3f9efe26c7042635d43b8ffd09d67936e3d0b6b901dc08a33e20313d361
  results:
    - description: The precise commit SHA that was fetched by this Task for the source repo
      name: commit
    - description: The precise URL that was fetched by this Task for the source repo
      name: url
    - description: The precise commit SHA that was fetched by this Task for the config repo
      name: commit_config
    - description: The precise URL that was fetched by this Task for the config repo
      name: url_config
  steps:
    - image: $(params.GIT_IMAGE)
      name: clone-source-code
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR_SOURCE)
      script: >
        #!/bin/sh

        set -eu -o pipefail


        if [[ "$(params.VERBOSE)" == "true" ]] ; then
          set -x
        fi


        CHECKOUT_DIR="$(workspaces.source.path)/$(params.CONTEXT_DIR_SOURCE)"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf $CHECKOUT_DIR" because $CHECKOUT_DIR might be "/"
          # or the root of a mounted volume.
          if [[ -d "$CHECKOUT_DIR" ]] ; then
            # Delete non-hidden files and directories
            rm -rf "$CHECKOUT_DIR"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "$CHECKOUT_DIR"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "$CHECKOUT_DIR"/..?*
          fi
        }


        if [[ "$(params.GIT_DELETE_EXISTING)" == "true" ]] ; then
          cleandir
        fi


        test -z "$(params.HTTP_PROXY)" || export HTTP_PROXY=$(params.HTTP_PROXY)

        test -z "$(params.HTTPS_PROXY)" || export HTTPS_PROXY=$(params.HTTPS_PROXY)

        test -z "$(params.NO_PROXY)" || export NO_PROXY=$(params.NO_PROXY)

        /ko-app/git-init -url="$(params.GIT_URL)" -revision="$(params.GIT_REVISION)" -refspec="$(params.GIT_REF)" -path="$CHECKOUT_DIR" -sslVerify="$(params.GIT_SSL_VERIFY)" -submodules="$(params.GIT_SUBMODULES)" -depth="$(params.GIT_DEPTH)" -sparseCheckoutDirectories="$(params.GIT_SPARSE_CHECKOUT_DIRS)"

        cd "$CHECKOUT_DIR"

        RESULT_SHA="$(git rev-parse HEAD)"

        EXIT_CODE="$?"

        if [ "$EXIT_CODE" != 0 ] ; then
          exit $EXIT_CODE
        fi

        git checkout -b $(params.GIT_REVISION)

        chmod -R o+w "$CHECKOUT_DIR"

        # ensure we don't add a trailing newline to the result
        echo -n "$RESULT_SHA" > $(results.commit.path)

        echo -n "$(params.GIT_URL)" > $(results.url.path)
        
        id
      securityContext:
        privileged: true
    - image: $(params.GIT_IMAGE)
      name: clone-config-repo
      workingDir: $(workspaces.source.path)/$(params.CONTEXT_DIR_CONFIG)
      script: >
        #!/bin/sh

        set -eu -o pipefail


        if [[ "$(params.VERBOSE)" == "true" ]] ; then
          set -x
        fi

        CHECKOUT_DIR="$(workspaces.source.path)/$(params.CONTEXT_DIR_CONFIG)"

        cleandir() {
          # Delete any existing contents of the repo directory if it exists.
          #
          # We don't just "rm -rf $CHECKOUT_DIR" because $CHECKOUT_DIR might be "/"
          # or the root of a mounted volume.
          if [[ -d "$CHECKOUT_DIR" ]] ; then
            # Delete non-hidden files and directories
            rm -rf "$CHECKOUT_DIR"/*
            # Delete files and directories starting with . but excluding ..
            rm -rf "$CHECKOUT_DIR"/.[!.]*
            # Delete files and directories starting with .. plus any other character
            rm -rf "$CHECKOUT_DIR"/..?*
          fi
        }

        clone_config_repo() {
          if [[ "$(params.GIT_DELETE_EXISTING)" == "true" ]] ; then
            cleandir
          fi

          test -z "$(params.HTTP_PROXY)" || export HTTP_PROXY=$(params.HTTP_PROXY)

          test -z "$(params.HTTPS_PROXY)" || export HTTPS_PROXY=$(params.HTTPS_PROXY)

          test -z "$(params.NO_PROXY)" || export NO_PROXY=$(params.NO_PROXY)

          /ko-app/git-init -url="$(params.GIT_CONFIG_URL)" -revision="$(params.GIT_CONFIG_REVISION)" -refspec="$(params.GIT_CONFIG_REF)" -path="$CHECKOUT_DIR" -sslVerify="$(params.GIT_CONFIG_SSL_VERIFY)" -submodules="$(params.GIT_CONFIG_SUBMODULES)" -depth="$(params.GIT_CONFIG_DEPTH)" -sparseCheckoutDirectories="$(params.GIT_CONFIG_SPARSE_CHECKOUT_DIRS)"

          cd "$CHECKOUT_DIR"

          RESULT_SHA="$(git rev-parse HEAD)"

          EXIT_CODE="$?"

          if [ "$EXIT_CODE" != 0 ] ; then
            exit $EXIT_CODE
          fi

          git checkout -b $(params.GIT_CONFIG_REVISION)

          chmod -R o+w "$CHECKOUT_DIR"

          # ensure we don't add a trailing newline to the result
          echo -n "$RESULT_SHA" > $(results.commit_config.path)

          echo -n "$(params.GIT_CONFIG_URL)" > $(results.url_config.path)

        }

        if [ "$(params.GIT_URL)" != "$(params.GIT_CONFIG_URL)" ] && [ -n "$(params.GIT_CONFIG_URL)" ] ; then
          clone_config_repo
        else
          echo "Source and config repo are the same. Skipping separate config repo clone."
          exit 0
        fi

        id
      securityContext:
        privileged: true
